# Design Manual
## 9032 Project ——— Developed by Lingxu Meng (z5147810)

### Overview

1. Display LCD screen with right output
2. Display LED lights with right output
3. Control motor to spin or stop
4. Push Button 0 interrupt
5. Get the keypad input value
6. Shuffle the ‘cups’ by generating a random number
7. Determine guess result and game status
8. Appendix

### 1. LCD Display

Most of initialisation code are from sample code from Lab04 — Task01. 


> LCD settings:	1. Connect LCD data pin D0-D7 to PORTL7-0.  
>                             2. Connect the four LCD control pins BE-RS to PORTA4-7.  


Two macros are designed to cooperate with LCD command and LCD data


> do_lcd_command: @0 is a binary code indicating a command  
> do_lcd_data: @0 is a binary code indicating a data  


Other functions can deal with LCD settings and debounce the electric signal.

LCD screen contents:

1. At the beginning, LCD screen would show  `Ready...`  to tell the user that the machine is ready.

2. When the player press PB0, LCD screen show `Start...`  to tell the user that this round has already start. 

3. And when the user press PB0 again and made a guess by pressing keypad, player’s score would be shown on LCD screen in this format: `Score:N` when player’s score is larger than 0.


### 2. LED Display

LEDs are divided into two groups. 

> LED settings:		1. Connect LED BAR pin0-2 to PORTC0-2 (three cups)  
> 					2. Connect LED BAR pin6-9 to PORTC4-7 (result indicators)  


Two macros are designed to cooperate with controlling turn on and turn off the LED by setting and clearing relative bit in PORTC. The scenario of executing these macros is when showing the correct answer by brighten the relative LED, flash four result indicator LEDs, bright three cup LEDs in dimmed light.

> turn_on_led: @0 is the LED supposed to be switched, set this bit  
> turn_off_led: @0 is the LED supposed to be switched, clear this bit  

LED dimmed light:

### 3. Motor Control

When the game is at start status and when player’s score becomes 0 and made a wrong guess, motor would start to spin. When the player pressed PB0 to make a guess and when during the game that the player’s score is not less than 0, the motor wouldn’t spin.

PORTC PIN3 is connected to MOTOR Mot, by setting and clearing the bit PORTC 3 can control the switch of motor.

> Motor settings:	 	1. Connect MOTOR  Mot pin to PORTC PIN3  

Two macros are designed to control the switch of motor

> motor_start:  set bit PORTC3, make motor spin   
> motor_stop: clear bin PORTC3, make motor stop  

### 4. Push Button 0 interrupt

If the Push Button 0 is pressed, an external interrupt trigger would response and start to execute different game status. LCD, LED and timer0 are initiated in RESET process.

### 5. Keypad Control

Most of initialisation code are from sample code from Lab04 — Task01. 

Four registers  `r16, r17, r18, r19`  are used during scan the keypad,  a subroutine `keypad` is executed to convert value of row and column to symbols on the keypad.

### 6. Shuffle the ‘cups’ by generating a random number

As there are totally three cups are shuffling, I decided to generate a number could be [0, 1, 2]. Timer0 is initialised to generate a random number according to time. To make the number become 0, 1 or 2. I designed a subroutine to imitate mod calculation. 


```asm6502
mod3:
	minus3:
	subi temp1, 3		; temp -= 3
	cpi temp1, 3		; compare temp1 with 3
	brsh minus3			; if temp >=3, continue the loop
	call sleep_5ms
	ret
```

### 7. Determine guess result and game status

Getting the value on `r16`  from the keypad ASCII that player pressed the key 0, 1 or 2 to make a guess and the value on `temp1`  generated by subroutine  `mod3` .
By comparing values in these two register, the program can make a decision whether this guess is correct. Then increase or decrease player’s score.
If a guess is correct, score = score + 1
If a guess is incorrect. Firstly, determine whether score equal to 0, if so, go back to start status. Then, score = score - 1. After the decrement, determine again whether score is 0, if so, go back to start status, otherwise, show score on the LCD screen.

### 8. Appendix

**Register used**

```asm6502
.def row    =r16		; value for row number
.def col    =r17		; value for column number
.def rmask  =r18		; mask for current row during scan
.def cmask  =r19		; mask for current column during scan
.def temp1  =r20		; used as template parameter
.def temp2  =r21		; used as template parameter
   
.def score  =r22			; record player's score
.def gameStatus = r23		; initial game status ==> gameStatus=0; playing game status ==> gameStatus=1
.def gameStart = r15		; flag to see whether the game has start
```

`r16`  is also used repeatedly during other cycles (setting delays, loading keypad value, recording lcd command and data)

**Program and Data Organisation**

```asm6502
.dseg
    KeypadValue: .byte 1
```

```asm6502
.equ PORTF_DIR =0xF0		; use PORTF for input/output from keypad: PF7-4, output, PF3-0, input
.equ INITCOLMASK = 0xEF		; scan from the leftmost column, the value to mask output
.equ INITROWMASK = 0x01		; scan from the bottom row
.equ ROWMASK  =0x0F			; low four bits are output from the keypad. This value mask the high 4 bits.

;lcd needed function
.equ LCD_RS = 7
.equ LCD_E = 6
.equ LCD_RW = 5
.equ LCD_BE = 4
```

**Flow Chart**

![pic](https://github.com/JosephMLX/PGlife/blob/master/COMP9032/lab03/Project/Flow%20Chart.jpg)
